# 2018-10-28

## 图论

1. 拓扑排序算法(top sort)
    1. 核心思路: 以一个**入度**为0的顶点，删除它并将它指向的所有节点入度-1。然后查找下一个入度为0的顶点，做相同操作直到所有顶点都被删除
    2. 限制: 不能有圈
    3. 实现算法的细节及技巧
        1. 需要一个indegree数组，记录每个节点的入度，算法初始时先遍历所有节点并计算入度，复杂度O(|E|)
        2. 需要有一个队列queue，存储所有入度为0的节点，当queue为空时程序结束

## 插件机制

预约模块的代码架构设计，之前想用**代理模式**来实现：使用代理类封装原始的模块代码，最后交由框架来执行。代理模式的问题在于，对每个原始类都要生成一个对应的`代理类`，代理类需要写很多*模板代码*，没有达到我要的效果

于是想到**插件模式**，在`windwane`里了解了很多，比较符合现在的场景。每个模块都是一个`plugin`，开发者只需按plugin的格式完成一个模块的功能，其他的交由框架来处理和执行。因为plugin的执行和实现是分开的，整个库的扩展性会非常好

## 复习设计模式

1. 模块模式

    用**立即执行函数**封装的代码，或者用`ES6`语法实现的代码，都是模块

    特点：有独立的作用域，可以与外界交互（`return` or `export`）

2. 单例模式

    **对象字面量**是一种单例模式

    因为单例模式需要存放一个`instance`变量，所以需要闭包，可以用`立即执行函数`实现，也可以单独抽象成一个类

3. 工厂模式

    > 工厂模式用于创建对象，而不公开实例化逻辑。当我们需要根据特定条件生成不同的对象时，可以使用此模式

4. 装饰模式

    装饰器只是一个语法糖，可以用原生方式实现

    核心思想，是扩展**原来的对象**的功能，至于方式需遵循语言特性，ES6有**装饰器语法@**